package com.lion.testutil.util.format;import com.alibaba.fastjson.JSONObject;import com.lion.testutil.Config;import com.lion.testutil.util.EncryptUtil;import com.lion.testutil.util.excel.ExcelHeaderType;import org.apache.http.message.BasicNameValuePair;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.UnsupportedEncodingException;import java.security.NoSuchAlgorithmException;import java.text.SimpleDateFormat;import java.util.ArrayList;import java.util.Date;import java.util.HashMap;public class ProductParamFormat {    private static final Logger LOG = LoggerFactory.getLogger(ProductParamFormat.class);    /**     * 将输入的参数转变成POST请求参数对象并返回。     *     * @param customInfo  客户信息，使用HashMap键值对方式传入     * @param key         产品秘钥     * @param merchCode   商户号码     * @param productCode 产品号码     * @return POST请求参数     */    public static ArrayList<BasicNameValuePair> formatPostParam(            String productCode,            String merchCode,            String key,            HashMap<String, String> customInfo)    {        HashMap<String, String> formatParams = new HashMap<>();        /**         * 获取OrderID，客户信息的json串，TranTime，客户信息加密后的数据。         * */        String orderId = Config.ORDER_ID_PREFIX + System.currentTimeMillis();        HashMap<String, String> customInfo2 = new HashMap<>();        for(String k : customInfo.keySet()){            String newk = k;            for(ExcelHeaderType type : ExcelHeaderType.values()){                if(type.getRes().contains(k)){                    newk = type.getDist();                    break;                }            }            customInfo2.put(newk, customInfo.get(k));        }        /**         * 网络中默认编码集为ISO-8558-1，而本地为UTF-8         * 因此在本地加密时，需要使用UTF-8         * 而传递是使用ISO-8559-1，这样在服务端不会为乱码，且加密结果一致。         * */        String jsonISO = null;        String jsonUTF = JSONObject.toJSONString(customInfo2);        try {            jsonISO = new String(jsonUTF.getBytes(), "ISO-8859-1");        } catch (UnsupportedEncodingException e) {            LOG.error(e.getMessage(), e);        }        String tranTime = new SimpleDateFormat(Config.DATE_FORMAT).format(new Date());        String data = merchCode + orderId + productCode + jsonUTF + tranTime + key;        String sign;        try {            sign = EncryptUtil.MD5EncryptReturnLowerCase(data);        } catch (UnsupportedEncodingException | NoSuchAlgorithmException e) {            sign = "None";            LOG.error("加密失败，返回空\"None\"", e);        }        /**         * 存入HashMap中。         * */        formatParams.put(Config.MERCH_CODE, merchCode);        formatParams.put(Config.ORDER_ID_PREFIX, orderId);        formatParams.put(Config.CUSTOMER_INFO, jsonISO);        formatParams.put(Config.TRAN_TIME, tranTime);        formatParams.put(Config.PORDUCT_CODE, productCode);        formatParams.put(Config.SIGN, sign);        /**         * 将HashMap中的参数键值对，转成POST的请求参数键值对。         * */        ArrayList<BasicNameValuePair> postParams = new ArrayList<>();        for (String paramName : formatParams.keySet()) {            postParams.add(new BasicNameValuePair(paramName, formatParams.get(paramName)));        }        return postParams;    }}